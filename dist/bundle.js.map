{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtCA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;;AAEe;AACf;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA,6BAAe,oCAAU;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AChD+B;AACS;;AAExC;AACA;AACA,WAAW,QAAQ;AACnB;AACe;AACf;AACA,wBAAwB,gDAAO;;AAE/B;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,wBAAwB;;AAExB,qCAAqC;AACrC;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,WAAW,yDAAW;AACtB;;;;;;;;;;;;;;;;ACjCA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AAC6B;AACgB;;AAE7C,6BAAe,oCAAU;AACzB;AACA;AACA;;AAEA;AACA,cAAc,mDAAM;;AAEpB;AACA,4BAA4B,kBAAkB;AAC9C,yBAAyB,2DAAc;AACvC;AACA;AACA,aAAa;AACb;AACA,MAAM;AACN,qBAAqB,2DAAc;AACnC;;AAEA;AACA;;;;;;;;;;;;;;;;AC5BA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AAC6B;AAC7B,uBAAuB,IAAI,IAAI,aAAa;AACL;;AAEvC,6BAAe,oCAAU;AACzB;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;AACA,2BAA2B,mDAAM;AACjC,UAAU;AACV;AACA,UAAU;AACV,2BAA2B,wDAAW;AACtC;AACA;;AAEA;AACA;;;;;;UC7BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNuD;AACV;;AAE7C;AACA;AACA,uBAAuB,gEAAmB;AAC1C;;AAEA,uBAAuB,2DAAc;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO,KAAK,MAAM;AAClD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB;AACvB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB,MAAM;AAC7B;AACA,yBAAyB;AACzB,6BAA6B,GAAG;AAChC,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,YAAY,kCAAkC;AAC9C,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yBAAyB,KAAK;AAC9B,yBAAyB,KAAK;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,MAAM;AAC1B;AACA,sBAAsB;AACtB,0BAA0B,KAAK;AAC/B,0BAA0B,KAAK;AAC/B,sBAAsB;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB,uBAAuB;AACvD,SAAS,uBAAuB,uBAAuB;AACvD,SAAS,uBAAuB;AAChC;AACA;AACA;;AAEA;AACA,0C","sources":["webpack://study_mustache/./src/Scanner.js","webpack://study_mustache/./src/lookup.js","webpack://study_mustache/./src/nestedTokens.js","webpack://study_mustache/./src/parseTemplateTokens.js","webpack://study_mustache/./src/parseTokens.js","webpack://study_mustache/./src/renderTemplate.js","webpack://study_mustache/webpack/bootstrap","webpack://study_mustache/webpack/runtime/define property getters","webpack://study_mustache/webpack/runtime/hasOwnProperty shorthand","webpack://study_mustache/webpack/runtime/make namespace object","webpack://study_mustache/./src/index.js"],"sourcesContent":["export default class Scanner {\n    // 实例化一个扫描器，构造时提供一个参数，这个参数就是字符串\n    // 也就是说这个扫描器就是针对这个字符串工作的\n    constructor(templateStr) {\n        this.templateStr = templateStr\n        this.pos = 0 // 指针\n        this.tail = templateStr // 还没走过的字符串，简称：尾巴\n    }\n\n    // 功能弱，只是用来跳过指定的内容，没有返回值\n    scan(tag) {\n        if (this.tail.indexOf(tag) === 0) {\n            // 指定内容的长度是多少，就让指针后移多少\n            this.pos += tag.length\n            this.tail = this.templateStr.substring(this.pos)\n        }\n    }\n\n    // 让指进行扫描，直到遇到寻找的内容结束，并且能够返回结束扫描之前走过的字符串\n    scanUntil(stopTag) {\n        // 记录执行此方法pos指针的起始值\n        const pos_backup = this.pos\n\n        // 扫描stopTag不在首位，而且指针没有到最后，那么继续扫描\n        while (!this.eos() && this.tail.indexOf(stopTag) !== 0) {\n            this.pos++\n            // 指针从该字符开始，直到最后的全部字符\n            this.tail = this.templateStr.substring(this.pos)\n        }\n\n        // 返回扫描到stopTag在首位，之前的走过字符串\n        return this.templateStr.substring(pos_backup, this.pos)\n    }\n\n    // end of string 判断指针是否到头了\n    eos() {\n        return this.pos >= this.templateStr.length\n    }\n}","/**\n * 根据传入的字符串寻找对象中的值\n * @param {object} data \n * @param {string} keyName \n */\n\nexport default function lookup(data, keyName) {\n    if (!data) return data\n    let temp = data\n\n    // 字符串中传值 \".\" 且 本身不是 \".\"\n    if (keyName.indexOf('.') != 0 && keyName !== '.') {\n        const keys = keyName.split('.')\n        for (let index = 0; index < keys.length; index++) {\n            const key = keys[index]\n            // 有值才往下找\n            if (temp[key]) {\n                temp = temp[key]\n            } else {\n                throw new Error('寻找的值不存在')\n            }\n        }\n    } else {\n        temp = temp[keyName]\n    }\n\n    return temp\n}\n","/**\n * 传入一维的tokens，实现按照层级结构进行折叠\n * @param {array} tokens \n * @returns \n */\n\nexport default function (tokens) {\n    // 最终结果\n    let nestedTokens = []\n\n    // 栈结构，存放小tokens。栈顶的tokens数组中当前操作的这个tokens的第三项小数组\n    let sections = []\n\n    /**\n     * 收集器，默认指向nestedTkens结果数组\n     * 当匹配到 # 的时候，改变收集器的指向，指向到当前token中新开辟的下一个维度的token\n     * 当匹配到 / 的时候，改变收集器的指向，判断当前栈sections是否有值？有值，则指向当前的栈顶；没值，则指向最终结果 nestedTokens\n     */\n    let collector = nestedTokens\n\n    for (let index = 0; index < tokens.length; index++) {\n        const token = tokens[index]\n        switch (token[0]) {\n            case '#':\n                // 收集当前维度的 子项\n                collector.push(token)\n                // 入栈\n                sections.push(token)\n                // 给当前匹配到的 #开头的token数组，开辟下标为2的下一个维度的子项，并且值为[]\n                token[2] = []\n                // 修正当前的收集器指向 新开辟的子项\n                collector = token[2]\n                break\n            case '/':\n                //出栈\n                sections.pop()\n\n                collector = sections.length\n                    ? sections[sections.length - 1][2]\n                    : nestedTokens\n                break\n            default:\n                // 无需关心当前是什么维度，没有匹配到 # 或者 、 字符串时，直接收集token即可\n                collector.push(token)\n        }\n    }\n\n    return nestedTokens\n}","import Scanner from './Scanner'\nimport nestedToken from './nestedTokens'\n\n/**\n * 将模板字符串转换为tokens\n * @param {string} templateStr \n */\nexport default function parseTemplateToTokens(templateStr) {\n    let tokens = []\n    const scanner = new Scanner(templateStr)\n\n    let words\n    while (!scanner.eos()) {\n        words = scanner.scanUntil('{{')\n        if (words) {\n            tokens.push(['text', words])\n        }\n        scanner.scan('{{')\n\n        words = scanner.scanUntil('}}')\n        if (words) {\n            if (words[0] === '#') {\n                tokens.push(['#', words.substring(1)])\n            } else if (words[0] === '/') {\n                tokens.push(['/', words.substring(1)])\n            } else {\n                tokens.push(['name', words])\n            }\n        }\n        scanner.scan('}}')\n    }\n\n    return nestedToken(tokens)\n}","/**\n * 处理数组、对象循环，结合renderTemplate实现递归\n * @param {array} token \n * @param {object} data \n */\nimport lookup from './lookup'\nimport renderTemplate from './renderTemplate'\n\nexport default function (token, data) {\n    let resultStr = ''\n    const key = token[1]\n    const childTokens = token[2]\n\n    // data中的实际数据，决定循环的方式\n    const v = lookup(data, key)\n\n    if (Array.isArray(v)) {\n        for (let index = 0; index < v.length; index++) {\n            resultStr += renderTemplate(childTokens, {\n                ...v[index],\n                '.': v[index]\n            })\n        }\n    } else if (typeof v === 'object') {\n        resultStr += renderTemplate(childTokens, v)\n    }\n\n    return resultStr\n}","/**\n * 将tokens和data结合，生成DOM字符串\n * @param {array} tokens \n * @param {object} data \n * @returns \n */\nimport lookup from './lookup'\n// console.log(lookup({a: {b: {c: '我才是结果'}}}, 'a.b.c'))\nimport parseTokens from './parseTokens'\n\nexport default function (tokens, data) {\n    let templateStr = ''\n\n    for (let index = 0; index < tokens.length; index++) {\n        const token = tokens[index]\n\n        const type = token[0]\n        const key = token[1]\n\n        if (type === 'name') {\n            templateStr += lookup(data, key)\n        } else if (type === 'text') {\n            templateStr += key\n        } else if (type === '#') {\n            templateStr += parseTokens(token, data)\n        }\n    }\n\n    return templateStr\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import parseTemplateTokens from './parseTemplateTokens'\nimport renderTemplate from './renderTemplate'\n\nconst myTemplateEngine = {\n    render(templateStr, data) {\n        const tokens = parseTemplateTokens(templateStr)\n        console.log('tokens', tokens)\n\n        const domStr = renderTemplate(tokens, data)\n        console.log('domStr', domStr)\n\n        let container = document.getElementById('container')\n        container.innerHTML = domStr // 上树\n        container = null\n    }\n}\n\n// 测试用例一\n// const templateStr = '今天开始学习{{thing}}，我好{{mood}}啊'\n// const data = {\n//     thing: 'mustache',\n//     mood: '开心'\n// }\n\n\n// 测试用例二\n// const templateStr = `\n//     <div>\n//         <ol>\n//             {{#students}}\n//             <li class=\"students\">\n//                 学生{{.}}\n//             </li>\n//             {{/students}}\n//         </ol>\n//     </div>\n// `\n// const data = {\n//     students: ['小明', '小强', '小王']\n// }\n\n\n// 测试用例三\n// const templateStr = `\n//     <div>\n//         <ol>\n//             {{#students}}\n//             <li class=\"hobbies\">\n//                 学生{{name}}的爱好\n//                 <ol>\n//                     {{#hobbies}}\n//                     <li>{{.}}</li>\n//                     {{/hobbies}}\n//                 </ol>\n//             </li>\n//             {{/students}}\n//         </ol>\n//     </div>\n// `\n// const data = {\n//     students: [\n//         {name: '小明', hobbies: ['游戏', '打球']},\n//         {name: '小强', hobbies: ['吃饭', '睡觉']},\n//         {name: '小王', hobbies: ['打豆豆', '游泳']}\n//     ]\n// }\n\n\n// -----------------------------\n// 增加循环的对象是对象\n\n// 测试用例四\n// const templateStr = `\n//     <div>\n//         <ol>\n//             {{#hobbies}}\n//             <div class=\"hobbies\">\n//                 <li>{{one}}</li>\n//                 <li>{{two}}</li>\n//             </div>\n//             {{/students}}\n//         </ol>\n//     </div>\n// `\n// const data = {\n//     hobbies: { one: '游戏', two: '打球' }\n// }\n\n\n// 测试用例五\nconst templateStr = `\n    <div>\n        <ol>\n            {{#students}}\n            <li class=\"hobbies\">\n                学生{{name}}的爱好\n                <ol>\n                    {{#hobbies}}\n                    <li>{{one}}</li>\n                    <li>{{two}}</li>\n                    {{/hobbies}}\n                </ol>\n            </li>\n            {{/students}}\n        </ol>\n    </div>\n`\nconst data = {\n    students: [\n        {name: '小明', hobbies: { one: '游戏', two: '打球' }},\n        {name: '小强', hobbies: { one: '游戏', two: '打球' }},\n        {name: '小王', hobbies: { one: '游戏', two: '打球' }}\n    ]\n    \n}\n\n// 执行\nmyTemplateEngine.render(templateStr, data)"],"names":[],"sourceRoot":""}